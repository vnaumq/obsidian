[[Advanced]]

Асинхронность в python была стандартизирована сравнительно недавно. Библиотека `asyncio` появилась впервые в версии 3.5 (то есть в 2015 году), хотя возможность костыльно писать асинхронные приложения и даже фреймворки, конечно, была и раньше.

Пример ассинхронного кода: 
```python
import asyncio
import time

async def fun1(x):
	print(x**2)
	await asyncio.sleep(3)
	print('fun1 завершена')
	
async def fun2(x):
	print(x**0.5)
	await asyncio.sleep(3)
	print('fun2 завершена')

async def main():
	
	task1 = asyncio.create_task(fun1(4))
	task2 = asyncio.create_task(fun2(4))
	await task1
	await task2
	
print(time.strftime('%X'))
asyncio.run(main())
print(time.strftime('%X'))
```

благодаря ключевому слову `async` она теперь возвращает не `<class 'NoneType'>`, а `<class 'coroutine'>`. Ничто превратилось в нечто! На сцену выходит новая сущность - **[[Корутина]]**.

асинхронная (или корутинная) функция — это `f`, а корутина — `f()`. Но если вы в разговоре назовете корутиной асинхронную функцию, беды большой не произойдет, вас поймут. "Не важно, какого цвета кошка, лишь бы она ловила мышей" (с) тов. Дэн Сяопин

```python
    print(type(task1))
    print(task1.__class__.__bases__)
```
Ага, значит [[Задача]] (что бы это ни значило) имеет тип `<class '_asyncio.Task'>`. Привет, капитан Очевидность!

А кто ваша мама, ребята? А мама наша — ~~анархия~~ какая-то еще более загадочная **[[Футура]]** (`<class '_asyncio.Future'>`).

Вернемся к примеру 2.2 и опишем его логику заново, используя теперь уже знакомые нам термины — корутины и задачи:
- корутину асинхронной функции `fun1` обернули задачей `task1`
- корутину асинхронной функции `fun2` обернули задачей `task2`
- в асинхронной функции main обозначили точку переключения к задаче `task1`
- в асинхронной функции main обозначили точку переключения к задаче `task2`
- корутину асинхронной функции `main` передали в функцию `asyncio.run`
